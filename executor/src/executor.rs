use agent_core::{Message, Result};
use memory::MemoryStore;
use planner::{Plan, Step};
use tools::ToolRegistry;

use crate::types::{ExecutionResult, StepResult};

/// The Executor is responsible for running plans generated by the planner.
///
/// It takes a plan with a sequence of steps and executes them in order,
/// managing tool invocations and storing results in memory for context.
pub struct Executor {
    /// Registry of available tools
    tools: ToolRegistry,
    /// Memory store for conversation context
    memory: Box<dyn MemoryStore>,
}

impl Executor {
    /// Creates a new Executor with the given tool registry and memory store.
    ///
    /// # Arguments
    /// * `tools` - The tool registry containing available tools
    /// * `memory` - The memory store for conversation context
    ///
    /// # Returns
    /// A new Executor instance
    pub fn new(tools: ToolRegistry, memory: Box<dyn MemoryStore>) -> Self {
        Self { tools, memory }
    }

    /// Lists all available tools in the registry.
    ///
    /// # Returns
    /// A vector of ToolInfo containing name, description, and schema for each tool
    pub fn list_tools(&self) -> Vec<tools::ToolInfo> {
        self.tools.list_tools()
    }

    /// Executes a complete plan by running each step sequentially.
    ///
    /// This method iterates through all steps in the plan, executing each one
    /// and collecting the results. After each step, the result is added to memory
    /// to provide context for subsequent steps.
    ///
    /// # Arguments
    /// * `plan` - The plan to execute
    ///
    /// # Returns
    /// An ExecutionResult containing the success status, final response, and all step results
    pub async fn execute_plan(&mut self, plan: Plan) -> Result<ExecutionResult> {
        let mut step_results = Vec::new();
        let mut final_response = String::new();
        let mut overall_success = true;

        // Execute each step in sequence
        for step in plan.steps {
            match self.execute_step(&step).await {
                Ok(step_result) => {
                    // Add result to memory for context
                    let message = Message::assistant(step_result.output.clone());
                    self.memory.add_message(message);

                    // If this is a Response step, use it as the final response
                    if step_result.step_type == "response" {
                        final_response = step_result.output.clone();
                    }

                    step_results.push(step_result);
                }
                Err(e) => {
                    // Step failed - record the failure and stop execution
                    let step_result =
                        StepResult::failure("error", format!("Step execution failed: {}", e));
                    step_results.push(step_result);
                    overall_success = false;
                    break;
                }
            }
        }

        // If no explicit response step was found, build a response from the results
        if final_response.is_empty() && !step_results.is_empty() {
            final_response = step_results
                .iter()
                .filter(|r| r.success)
                .map(|r| r.output.as_str())
                .collect::<Vec<_>>()
                .join("\n");
        }

        Ok(ExecutionResult {
            success: overall_success,
            final_response,
            step_results,
        })
    }

    /// Executes a single step from the plan.
    ///
    /// This method pattern matches on the step type and delegates to the
    /// appropriate handler. For ToolCall steps, it calls handle_tool_call.
    /// For Reasoning and Response steps, it returns the text as the result.
    ///
    /// # Arguments
    /// * `step` - The step to execute
    ///
    /// # Returns
    /// A StepResult containing the step type, output, and success status
    async fn execute_step(&mut self, step: &Step) -> Result<StepResult> {
        match step {
            Step::ToolCall(tool_call) => self.handle_tool_call(tool_call).await,
            Step::Reasoning { text } => Ok(StepResult::success("reasoning", text.clone())),
            Step::Response { text } => Ok(StepResult::success("response", text.clone())),
        }
    }

    /// Handles the execution of a tool call.
    ///
    /// This method looks up the tool in the registry, executes it with the
    /// provided parameters, and wraps the result in a StepResult. If the tool
    /// is not found or execution fails, an error is returned.
    ///
    /// # Arguments
    /// * `tool_call` - The tool call to execute
    ///
    /// # Returns
    /// A StepResult containing the tool output or an error
    async fn handle_tool_call(&mut self, tool_call: &planner::ToolCall) -> Result<StepResult> {
        // Look up the tool in the registry
        let tool = self
            .tools
            .get(&tool_call.tool_name)
            .ok_or_else(|| agent_core::AgentError::ToolNotFound(tool_call.tool_name.clone()))?;

        // Execute the tool with the provided parameters
        match tool.execute(tool_call.parameters.clone()).await {
            Ok(result) => {
                // Convert the JSON result to a string for the step result
                let output =
                    serde_json::to_string_pretty(&result).unwrap_or_else(|_| result.to_string());

                Ok(StepResult::success(
                    format!("tool_call:{}", tool_call.tool_name),
                    output,
                ))
            }
            Err(e) => Err(agent_core::AgentError::ToolExecution {
                tool_name: tool_call.tool_name.clone(),
                reason: e.to_string(),
            }),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use agent_core::Message;
    use async_trait::async_trait;
    use planner::{Plan, Step, ToolCall};
    use serde_json::{Value, json};
    use std::sync::{Arc, Mutex};

    // Mock MemoryStore for testing
    #[derive(Clone)]
    struct MockMemoryStore {
        messages: Arc<Mutex<Vec<Message>>>,
    }

    impl MockMemoryStore {
        fn new() -> Self {
            Self {
                messages: Arc::new(Mutex::new(Vec::new())),
            }
        }

        fn get_messages(&self) -> Vec<Message> {
            self.messages.lock().unwrap().clone()
        }
    }

    impl MemoryStore for MockMemoryStore {
        fn add_message(&mut self, message: Message) {
            self.messages.lock().unwrap().push(message);
        }

        fn get_recent(&self, limit: usize) -> Vec<Message> {
            let messages = self.messages.lock().unwrap();
            messages.iter().rev().take(limit).rev().cloned().collect()
        }

        fn get_within_budget(&self, _token_budget: usize) -> Vec<Message> {
            self.messages.lock().unwrap().clone()
        }

        fn clear(&mut self) {
            self.messages.lock().unwrap().clear();
        }
    }

    // Mock Tool that always succeeds
    struct MockSuccessTool {
        name: String,
        result: Value,
    }

    impl MockSuccessTool {
        fn new(name: &str, result: Value) -> Self {
            Self {
                name: name.to_string(),
                result,
            }
        }
    }

    #[async_trait]
    impl tools::Tool for MockSuccessTool {
        fn name(&self) -> &str {
            &self.name
        }

        fn description(&self) -> &str {
            "Mock tool for testing"
        }

        fn parameters_schema(&self) -> Value {
            json!({
                "type": "object",
                "properties": {}
            })
        }

        async fn execute(&self, _params: Value) -> Result<Value> {
            Ok(self.result.clone())
        }
    }

    // Mock Tool that always fails
    struct MockFailureTool {
        name: String,
    }

    impl MockFailureTool {
        fn new(name: &str) -> Self {
            Self {
                name: name.to_string(),
            }
        }
    }

    #[async_trait]
    impl tools::Tool for MockFailureTool {
        fn name(&self) -> &str {
            &self.name
        }

        fn description(&self) -> &str {
            "Mock tool that fails"
        }

        fn parameters_schema(&self) -> Value {
            json!({
                "type": "object",
                "properties": {}
            })
        }

        async fn execute(&self, _params: Value) -> Result<Value> {
            Err(agent_core::AgentError::ToolExecution {
                tool_name: self.name.clone(),
                reason: "Mock tool failure".to_string(),
            })
        }
    }

    #[tokio::test]
    async fn test_execute_step_reasoning() {
        let registry = ToolRegistry::new();
        let memory = Box::new(MockMemoryStore::new());
        let mut executor = Executor::new(registry, memory);

        let step = Step::Reasoning {
            text: "This is a reasoning step".to_string(),
        };

        let result = executor.execute_step(&step).await.unwrap();
        assert_eq!(result.step_type, "reasoning");
        assert_eq!(result.output, "This is a reasoning step");
        assert!(result.success);
    }

    #[tokio::test]
    async fn test_execute_step_response() {
        let registry = ToolRegistry::new();
        let memory = Box::new(MockMemoryStore::new());
        let mut executor = Executor::new(registry, memory);

        let step = Step::Response {
            text: "This is a response".to_string(),
        };

        let result = executor.execute_step(&step).await.unwrap();
        assert_eq!(result.step_type, "response");
        assert_eq!(result.output, "This is a response");
        assert!(result.success);
    }

    #[tokio::test]
    async fn test_execute_step_tool_call_success() {
        let mut registry = ToolRegistry::new();
        registry.register(Box::new(MockSuccessTool::new(
            "test_tool",
            json!({"result": "success"}),
        )));

        let memory = Box::new(MockMemoryStore::new());
        let mut executor = Executor::new(registry, memory);

        let tool_call = ToolCall::new("test_tool".to_string(), json!({}));
        let step = Step::ToolCall(tool_call);

        let result = executor.execute_step(&step).await.unwrap();
        assert_eq!(result.step_type, "tool_call:test_tool");
        assert!(result.output.contains("success"));
        assert!(result.success);
    }

    #[tokio::test]
    async fn test_handle_tool_call_valid_tool() {
        let mut registry = ToolRegistry::new();
        registry.register(Box::new(MockSuccessTool::new(
            "calculator",
            json!({"result": 42}),
        )));

        let memory = Box::new(MockMemoryStore::new());
        let mut executor = Executor::new(registry, memory);

        let tool_call = ToolCall::new("calculator".to_string(), json!({"a": 2, "b": 3}));

        let result = executor.handle_tool_call(&tool_call).await.unwrap();
        assert_eq!(result.step_type, "tool_call:calculator");
        assert!(result.output.contains("42"));
        assert!(result.success);
    }

    #[tokio::test]
    async fn test_handle_tool_call_invalid_tool() {
        let registry = ToolRegistry::new();
        let memory = Box::new(MockMemoryStore::new());
        let mut executor = Executor::new(registry, memory);

        let tool_call = ToolCall::new("nonexistent_tool".to_string(), json!({}));

        let result = executor.handle_tool_call(&tool_call).await;
        assert!(result.is_err());

        match result {
            Err(agent_core::AgentError::ToolNotFound(name)) => {
                assert_eq!(name, "nonexistent_tool");
            }
            _ => panic!("Expected ToolNotFound error"),
        }
    }

    #[tokio::test]
    async fn test_handle_tool_call_tool_execution_failure() {
        let mut registry = ToolRegistry::new();
        registry.register(Box::new(MockFailureTool::new("failing_tool")));

        let memory = Box::new(MockMemoryStore::new());
        let mut executor = Executor::new(registry, memory);

        let tool_call = ToolCall::new("failing_tool".to_string(), json!({}));

        let result = executor.handle_tool_call(&tool_call).await;
        assert!(result.is_err());

        match result {
            Err(agent_core::AgentError::ToolExecution { tool_name, reason }) => {
                assert_eq!(tool_name, "failing_tool");
                assert!(reason.contains("Mock tool failure"));
            }
            _ => panic!("Expected ToolExecution error"),
        }
    }

    #[tokio::test]
    async fn test_execute_plan_single_step() {
        let registry = ToolRegistry::new();
        let memory = Box::new(MockMemoryStore::new());
        let mut executor = Executor::new(registry, memory);

        let plan = Plan::new(
            vec![Step::Response {
                text: "Hello, world!".to_string(),
            }],
            "Simple single-step plan".to_string(),
        );

        let result = executor.execute_plan(plan).await.unwrap();
        assert!(result.success);
        assert_eq!(result.final_response, "Hello, world!");
        assert_eq!(result.step_results.len(), 1);
        assert!(result.step_results[0].success);
    }

    #[tokio::test]
    async fn test_execute_plan_multi_step() {
        let mut registry = ToolRegistry::new();
        registry.register(Box::new(MockSuccessTool::new(
            "tool1",
            json!({"data": "result1"}),
        )));
        registry.register(Box::new(MockSuccessTool::new(
            "tool2",
            json!({"data": "result2"}),
        )));

        let memory = Box::new(MockMemoryStore::new());
        let mut executor = Executor::new(registry, memory);

        let plan = Plan::new(
            vec![
                Step::Reasoning {
                    text: "First, I'll use tool1".to_string(),
                },
                Step::ToolCall(ToolCall::new("tool1".to_string(), json!({}))),
                Step::Reasoning {
                    text: "Now I'll use tool2".to_string(),
                },
                Step::ToolCall(ToolCall::new("tool2".to_string(), json!({}))),
                Step::Response {
                    text: "All done!".to_string(),
                },
            ],
            "Multi-step plan".to_string(),
        );

        let result = executor.execute_plan(plan).await.unwrap();
        assert!(result.success);
        assert_eq!(result.final_response, "All done!");
        assert_eq!(result.step_results.len(), 5);
        assert!(result.step_results.iter().all(|r| r.success));
    }

    #[tokio::test]
    async fn test_execute_plan_with_failure() {
        let mut registry = ToolRegistry::new();
        registry.register(Box::new(MockSuccessTool::new(
            "good_tool",
            json!({"result": "ok"}),
        )));
        registry.register(Box::new(MockFailureTool::new("bad_tool")));

        let memory = Box::new(MockMemoryStore::new());
        let mut executor = Executor::new(registry, memory);

        let plan = Plan::new(
            vec![
                Step::ToolCall(ToolCall::new("good_tool".to_string(), json!({}))),
                Step::ToolCall(ToolCall::new("bad_tool".to_string(), json!({}))),
                Step::Response {
                    text: "This should not execute".to_string(),
                },
            ],
            "Plan with failure".to_string(),
        );

        let result = executor.execute_plan(plan).await.unwrap();
        assert!(!result.success);
        // Should have 2 step results: one success, one failure
        assert_eq!(result.step_results.len(), 2);
        assert!(result.step_results[0].success);
        assert!(!result.step_results[1].success);
    }

    #[tokio::test]
    async fn test_execute_plan_stores_results_in_memory() {
        let mut registry = ToolRegistry::new();
        registry.register(Box::new(MockSuccessTool::new(
            "test_tool",
            json!({"result": "data"}),
        )));

        let memory_store = MockMemoryStore::new();
        let memory_clone = memory_store.clone();
        let mut executor = Executor::new(registry, Box::new(memory_store));

        let plan = Plan::new(
            vec![
                Step::Reasoning {
                    text: "Thinking...".to_string(),
                },
                Step::ToolCall(ToolCall::new("test_tool".to_string(), json!({}))),
                Step::Response {
                    text: "Done!".to_string(),
                },
            ],
            "Plan to test memory".to_string(),
        );

        executor.execute_plan(plan).await.unwrap();

        // Check that results were stored in memory
        let messages = memory_clone.get_messages();
        assert_eq!(messages.len(), 3);
        assert!(messages[0].content.contains("Thinking"));
        assert!(messages[1].content.contains("data"));
        assert!(messages[2].content.contains("Done"));
    }

    #[tokio::test]
    async fn test_execute_plan_empty_plan() {
        let registry = ToolRegistry::new();
        let memory = Box::new(MockMemoryStore::new());
        let mut executor = Executor::new(registry, memory);

        let plan = Plan::new(vec![], "Empty plan".to_string());

        let result = executor.execute_plan(plan).await.unwrap();
        assert!(result.success);
        assert_eq!(result.final_response, "");
        assert_eq!(result.step_results.len(), 0);
    }

    #[tokio::test]
    async fn test_execute_plan_no_explicit_response() {
        let mut registry = ToolRegistry::new();
        registry.register(Box::new(MockSuccessTool::new(
            "tool1",
            json!({"result": "output1"}),
        )));
        registry.register(Box::new(MockSuccessTool::new(
            "tool2",
            json!({"result": "output2"}),
        )));

        let memory = Box::new(MockMemoryStore::new());
        let mut executor = Executor::new(registry, memory);

        let plan = Plan::new(
            vec![
                Step::ToolCall(ToolCall::new("tool1".to_string(), json!({}))),
                Step::ToolCall(ToolCall::new("tool2".to_string(), json!({}))),
            ],
            "Plan without explicit response".to_string(),
        );

        let result = executor.execute_plan(plan).await.unwrap();
        assert!(result.success);
        // Should build response from step outputs
        assert!(result.final_response.contains("output1"));
        assert!(result.final_response.contains("output2"));
        assert_eq!(result.step_results.len(), 2);
    }

    #[tokio::test]
    async fn test_list_tools() {
        let mut registry = ToolRegistry::new();
        registry.register(Box::new(MockSuccessTool::new(
            "tool1",
            json!({"result": "ok"}),
        )));
        registry.register(Box::new(MockSuccessTool::new(
            "tool2",
            json!({"result": "ok"}),
        )));

        let memory = Box::new(MockMemoryStore::new());
        let executor = Executor::new(registry, memory);

        let tools = executor.list_tools();
        assert_eq!(tools.len(), 2);

        let tool_names: Vec<String> = tools.iter().map(|t| t.name.clone()).collect();
        assert!(tool_names.contains(&"tool1".to_string()));
        assert!(tool_names.contains(&"tool2".to_string()));
    }
}
