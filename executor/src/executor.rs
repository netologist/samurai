use agent_core::{Message, Result};
use memory::MemoryStore;
use planner::{Plan, Step};
use tools::ToolRegistry;

use crate::types::{ExecutionResult, StepResult};

/// The Executor is responsible for running plans generated by the planner.
/// 
/// It takes a plan with a sequence of steps and executes them in order,
/// managing tool invocations and storing results in memory for context.
pub struct Executor {
    /// Registry of available tools
    tools: ToolRegistry,
    /// Memory store for conversation context
    memory: Box<dyn MemoryStore>,
}

impl Executor {
    /// Creates a new Executor with the given tool registry and memory store.
    /// 
    /// # Arguments
    /// * `tools` - The tool registry containing available tools
    /// * `memory` - The memory store for conversation context
    /// 
    /// # Returns
    /// A new Executor instance
    pub fn new(tools: ToolRegistry, memory: Box<dyn MemoryStore>) -> Self {
        Self { tools, memory }
    }

    /// Lists all available tools in the registry.
    /// 
    /// # Returns
    /// A vector of ToolInfo containing name, description, and schema for each tool
    pub fn list_tools(&self) -> Vec<tools::ToolInfo> {
        self.tools.list_tools()
    }

    /// Executes a complete plan by running each step sequentially.
    /// 
    /// This method iterates through all steps in the plan, executing each one
    /// and collecting the results. After each step, the result is added to memory
    /// to provide context for subsequent steps.
    /// 
    /// # Arguments
    /// * `plan` - The plan to execute
    /// 
    /// # Returns
    /// An ExecutionResult containing the success status, final response, and all step results
    pub async fn execute_plan(&mut self, plan: Plan) -> Result<ExecutionResult> {
        let mut step_results = Vec::new();
        let mut final_response = String::new();
        let mut overall_success = true;

        // Execute each step in sequence
        for step in plan.steps {
            match self.execute_step(&step).await {
                Ok(step_result) => {
                    // Add result to memory for context
                    let message = Message::assistant(step_result.output.clone());
                    self.memory.add_message(message);

                    // If this is a Response step, use it as the final response
                    if step_result.step_type == "response" {
                        final_response = step_result.output.clone();
                    }

                    step_results.push(step_result);
                }
                Err(e) => {
                    // Step failed - record the failure and stop execution
                    let step_result = StepResult::failure(
                        "error",
                        format!("Step execution failed: {}", e),
                    );
                    step_results.push(step_result);
                    overall_success = false;
                    break;
                }
            }
        }

        // If no explicit response step was found, build a response from the results
        if final_response.is_empty() && !step_results.is_empty() {
            final_response = step_results
                .iter()
                .filter(|r| r.success)
                .map(|r| r.output.as_str())
                .collect::<Vec<_>>()
                .join("\n");
        }

        Ok(ExecutionResult {
            success: overall_success,
            final_response,
            step_results,
        })
    }

    /// Executes a single step from the plan.
    /// 
    /// This method pattern matches on the step type and delegates to the
    /// appropriate handler. For ToolCall steps, it calls handle_tool_call.
    /// For Reasoning and Response steps, it returns the text as the result.
    /// 
    /// # Arguments
    /// * `step` - The step to execute
    /// 
    /// # Returns
    /// A StepResult containing the step type, output, and success status
    async fn execute_step(&mut self, step: &Step) -> Result<StepResult> {
        match step {
            Step::ToolCall(tool_call) => {
                self.handle_tool_call(tool_call).await
            }
            Step::Reasoning { text } => {
                Ok(StepResult::success("reasoning", text.clone()))
            }
            Step::Response { text } => {
                Ok(StepResult::success("response", text.clone()))
            }
        }
    }

    /// Handles the execution of a tool call.
    /// 
    /// This method looks up the tool in the registry, executes it with the
    /// provided parameters, and wraps the result in a StepResult. If the tool
    /// is not found or execution fails, an error is returned.
    /// 
    /// # Arguments
    /// * `tool_call` - The tool call to execute
    /// 
    /// # Returns
    /// A StepResult containing the tool output or an error
    async fn handle_tool_call(&mut self, tool_call: &planner::ToolCall) -> Result<StepResult> {
        // Look up the tool in the registry
        let tool = self.tools.get(&tool_call.tool_name).ok_or_else(|| {
            agent_core::AgentError::ToolExecution {
                tool_name: tool_call.tool_name.clone(),
                reason: "Tool not found in registry".to_string(),
            }
        })?;

        // Execute the tool with the provided parameters
        match tool.execute(tool_call.parameters.clone()).await {
            Ok(result) => {
                // Convert the JSON result to a string for the step result
                let output = serde_json::to_string_pretty(&result)
                    .unwrap_or_else(|_| result.to_string());
                
                Ok(StepResult::success(
                    format!("tool_call:{}", tool_call.tool_name),
                    output,
                ))
            }
            Err(e) => {
                Err(agent_core::AgentError::ToolExecution {
                    tool_name: tool_call.tool_name.clone(),
                    reason: e.to_string(),
                })
            }
        }
    }
}
